#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Explore-Exploit fMRI: Neuron Paper
Extracting regressors for the pomdp-based fmri design
notes: Main code product are files: <regressors_final/cdn.txt>

author: jeremy hogeveen (jhogeveen@unm.edu)
last edit: March 9, 2022
"""

#%% Chunk 1: Importing packages and setting up the files we need
# Package import
from glob import glob
import os
import shutil
import numpy as np
import pandas as pd
import re
import ntpath

# setting up the paths
base_dir = os.path.dirname(os.getcwd())
regressor_dir = os.path.join(base_dir,'regressors_final')

# getting lists of matching files
eprime_files = glob(os.path.join(base_dir,'behave/*-EDAT-MRI.csv')) # has the basic timing info we need
custom_files = glob(os.path.join(base_dir,'behave/*-MRITRIALINFO_ACEFMRIMEG.csv')) # has reward feedback code in it
pomdp_files = glob(os.path.join(base_dir,'model_dat/pomdp_out/*_mdpout.txt')) # has the value and explore/exploit info we need
# NOTE: HAVEN'T ADDED CONFOUND FILES YET SINCE WE DON'T HAVE UPDATED FMRIPREP OUTPUT YET

# dummy vector for any blank regressor
dummy_vec = os.path.join(base_dir,'code/fsl_design/dummyvec.txt')
#%%

#%% Chunk 3: Generating regressors for the computational model-based analysis

# 1. Mean choice event act
# 2a. IEV
# 2b. REL_IEV
# 3. FEV
# 4. BON
# 5. TRLSNOV
# 6. PREREW
# 7. RPE

# ### Notes: 
# * regressor 1 is at the time of cue for duration stim dur. <-- SAME AS EVENT_RELATED MODEL, DON"T NEED A NEW ONE IN THIS CHUNK
# * regressors 2-6 modeled at the time of response for duration 0. 
# * Regressor 7 modeled at the time of outcome for duration 0.

for i in range(0,len(custom_files)):
    ### Step 1: Loading the data and generating
    # pulling pid from filename using regex
    cur_eprime_file = eprime_files[i]
    curfile = ntpath.basename(cur_eprime_file)
    pid = re.compile('^[^-]*[^ -]')
    cursub = pid.findall(curfile)[0]
    print('generating event-related regressors for:',cursub)
    # Setting run length
    runlength=422
    # Finding the custom eprime output file and pomdp output that correspond to eprime_files[i]
    cur_custom_file = [s for s in custom_files if cursub in s][0]
    cur_pomdp_file = [s for s in pomdp_files if cursub in s][0]
    # Reading in the data
    df_eprime = pd.read_csv(cur_eprime_file)
    df_custom = pd.read_csv(cur_custom_file)
    df_pomdp = pd.read_csv(cur_pomdp_file, sep='\t',header=None)
    df_pomdp = df_pomdp.dropna(axis='columns',how='all') # dropping an empty column that appears to exist in the pomdp files
    df_pomdp.columns=["pid", "Trial_pomdp", "chosenovel", "chosebest","choseworst", # labeling cols 1-5
                      "trlsnov","cQb","cQe","cQt","cQsa", #cols 6-10
                      "confidence","maxQt","novel_p","nominal_chosen_p","iev_dev", #labeling cols 11-15
                      "rel_iev_max","rel_iev_min","stim_ID"] #labeling cols 16-18
    # converting several of the vars to a float to make them easier to work with
    df_pomdp['trlsnov'] = df_pomdp['trlsnov'].astype('float')
    df_pomdp['confidence'] = df_pomdp['confidence'].astype('float')
    df_pomdp['cQb'] = df_pomdp['cQb'].astype('float') 
    df_pomdp['cQe'] = df_pomdp['cQe'].astype('float')
    df_pomdp['cQt'] = df_pomdp['cQt'].astype('float')
    df_pomdp['novel_p'] = df_pomdp['novel_p'].astype('float')
    df_pomdp['iev_dev'] = df_pomdp['iev_dev'].astype('float')
    df_pomdp['rel_iev_max'] = df_pomdp['rel_iev_max'].astype('float')
    df_pomdp['rel_iev_min'] = df_pomdp['rel_iev_min'].astype('float')
    df_pomdp['stim_ID'] = df_pomdp['stim_ID'].astype('float')
    
    #creating rel_iev ##tsm
    df_pomdp['rel_iev'] = (df_pomdp.rel_iev_max + df_pomdp.rel_iev_min ) /2
    
    ### Normalizing pomdp value regressors
    df_pomdp['bonus_norm'] = (df_pomdp.cQb - 0) / df_pomdp.cQb.std(ddof=0) # centering BONUS around 0
    df_pomdp['iev_norm'] = (df_pomdp.cQe - 0.5) / df_pomdp.cQe.std(ddof=0) # centering IEV around 0.5
    df_pomdp['fev_norm'] = (df_pomdp.cQt - 6.55) / df_pomdp.cQt.std(ddof=0) # centering FEV around first trial FEV
    df_pomdp['trlsnov_norm'] = df_pomdp['trlsnov'] / np.max(df_pomdp['trlsnov'])
    
    
    #center the variables
    df_pomdp['rel_iev_norm'] = df_pomdp.rel_iev - df_pomdp.rel_iev.mean() # centering relative IEV around mean
    
    ### merging the data frames
    df = pd.concat([df_eprime,df_pomdp,df_custom], axis=1) # merging the data frames
    
    ### Generating outcome binary and RPE
    df['outcome'] = np.where(df.bonus_norm.isnull(),999,np.where(df.rewarded == True,1,0)) # if rewarded is true, mark as is_reward    
    df['pred_err'] = df.outcome - df.cQe
    df['pred_err_norm'] = df.pred_err - df.pred_err.mean()
    
    ### subsetting by run
    df_run1 = df[df['Block']==1] # filtering to just Run 1 data
    df_run2 = df[df['Block']==2] # filtering to just Run 2 data
    df_run3 = df[df['Block']==3] # filtering to just Run 3 data
    df_run4 = df[df['Block']==4] # filtering to just Run 4 data
    ### Computing the onsets
    # Stim events
    def stim_onset(df):
        stim_onset_var = (df['SessChoice.OnsetTime'] - min(df['WaitForScanner.OffsetTime'])) / 1000
        return stim_onset_var
    df_run1['choice_stimOnset'] = stim_onset(df_run1)
    df_run2['choice_stimOnset'] = stim_onset(df_run2)
    df_run3['choice_stimOnset'] = stim_onset(df_run3)
    df_run4['choice_stimOnset'] = stim_onset(df_run4)
    # Response onsets
    def resp_onset(df):
        resp_onset_var = df['choice_stimOnset'] + (df['SessChoice.RT'] / 1000)
        return resp_onset_var
    df_run1['choice_respOnset'] = resp_onset(df_run1)
    df_run2['choice_respOnset'] = resp_onset(df_run2)
    df_run3['choice_respOnset'] = resp_onset(df_run3)
    df_run4['choice_respOnset'] = resp_onset(df_run4)
    # Outcome events
    def outcome_onset(df):
        outcome_onset_var = (df['SessScore.OnsetTime'] - min(df['WaitForScanner.OffsetTime'])) / 1000
        return outcome_onset_var
    df_run1['outcome_stimOnset'] = outcome_onset(df_run1)
    df_run1 = df_run1[df_run1['outcome_stimOnset']<runlength]
    df_run2['outcome_stimOnset'] = outcome_onset(df_run2)
    df_run2 = df_run2[df_run2['outcome_stimOnset']<runlength]
    df_run3['outcome_stimOnset'] = outcome_onset(df_run3)
    df_run3 = df_run3[df_run3['outcome_stimOnset']<runlength]
    df_run4['outcome_stimOnset'] = outcome_onset(df_run4)
    df_run4 = df_run4[df_run4['outcome_stimOnset']<runlength]
    # decision epoch (for variable epoch modeling of the HRF, cf. Grindband et al., 2008)
    def decision_dur(df):
        decision_dur_var = df['choice_respOnset'] - df['choice_stimOnset']
        return decision_dur_var
    df_run1['choice_decisionDur'] = decision_dur(df_run1)
    df_run2['choice_decisionDur'] = decision_dur(df_run2)
    df_run3['choice_decisionDur'] = decision_dur(df_run3)
    df_run4['choice_decisionDur'] = decision_dur(df_run4)
    
    ### Adding in previous outcome vector
    # Run 1
    df_run1['prev_outcome'] = np.where(df_run1.bonus_norm.shift().isnull(),999,np.where(df_run1.rewarded.shift() == True,1,0)) # if prev outcome is True, mark as a 1
    # Run 2
    df_run2['prev_outcome'] = np.where(df_run2.bonus_norm.shift().isnull(),999,np.where(df_run2.rewarded.shift() == True,1,0)) # if prev outcome is True, mark as a 1
    # Run 3
    df_run3['prev_outcome'] = np.where(df_run3.bonus_norm.shift().isnull(),999,np.where(df_run3.rewarded.shift() == True,1,0)) # if prev outcome is True, mark as a 1
    # Run 4
    df_run4['prev_outcome'] = np.where(df_run4.bonus_norm.shift().isnull(),999,np.where(df_run4.rewarded.shift() == True,1,0)) # if prev outcome is True, mark as a 1
    
    
    ##### Step 2: Extracting task regressor for FSL #####
    # creating an output directory for current sub if it doens't exist yet
    cursub_output_folder = os.path.join(regressor_dir,cursub)
    if not os.path.exists(cursub_output_folder):
        os.makedirs(cursub_output_folder)
    # Functions for the event-related regressors
    def cue_regr(df):
        out_df = pd.DataFrame({'onset':df['choice_stimOnset'],
                               'dur':df['SessChoice.Duration']/1000,
                               'weight':1})
        return out_df
    def pomdp_resp_regr(df,var):
        out_df = pd.DataFrame({'onset':df['choice_respOnset'],
                               'dur':0,
                               'weight':var})
        return out_df
    def pomdp_resp_epoch_regr(df,var):
        out_df = pd.DataFrame({'onset':df['choice_stimOnset'],
                               'dur':df['choice_decisionDur'],
                               'weight':var})
        return out_df
    def pomdp_outcome_regr(df,var):
        out_df = pd.DataFrame({'onset':df['outcome_stimOnset'],
                               'dur':0,
                               'weight':var})
        return out_df
    def save_regr(df,filename):
        if df.empty:
            shutil.copy(dummy_vec,filename)
        else:
            df.to_csv(filename, index=False, header=False,sep='\t')
            
    # Removing trials where resp is NaN
    df_run1 = df_run1[df_run1['iev_norm'].notna()]
    df_run2 = df_run2[df_run2['iev_norm'].notna()]
    df_run3 = df_run3[df_run3['iev_norm'].notna()]
    df_run4 = df_run4[df_run4['iev_norm'].notna()]
    
    # DF for mean stim-evoked activation as a regressor
    # Run 1
    df_run1_choice_mean_regressor = cue_regr(df_run1)
    run1_choice_mean_regressor_filename = os.path.join(cursub_output_folder,'run1_choice_mean.txt')
    save_regr(df_run1_choice_mean_regressor,run1_choice_mean_regressor_filename)
    # Run 2
    df_run2_choice_mean_regressor = cue_regr(df_run2)
    run2_choice_mean_regressor_filename = os.path.join(cursub_output_folder,'run2_choice_mean.txt')
    save_regr(df_run2_choice_mean_regressor,run2_choice_mean_regressor_filename)
    # Run 3
    df_run3_choice_mean_regressor = cue_regr(df_run3)
    run3_choice_mean_regressor_filename = os.path.join(cursub_output_folder,'run3_choice_mean.txt')
    save_regr(df_run3_choice_mean_regressor,run3_choice_mean_regressor_filename)
    # Run 4
    df_run4_choice_mean_regressor = cue_regr(df_run4)
    run4_choice_mean_regressor_filename = os.path.join(cursub_output_folder,'run4_choice_mean.txt')
    save_regr(df_run4_choice_mean_regressor,run4_choice_mean_regressor_filename)
    
    # DF for IEV activation as an instantaneous regressor
    # Run 1
    df_run1_iev_regressor = pomdp_resp_regr(df_run1,df_run1['iev_norm'])
    run1_iev_regressor_filename = os.path.join(cursub_output_folder,'run1_iev.txt')
    save_regr(df_run1_iev_regressor,run1_iev_regressor_filename)
    # Run 2
    df_run2_iev_regressor = pomdp_resp_regr(df_run2,df_run2['iev_norm'])
    run2_iev_regressor_filename = os.path.join(cursub_output_folder,'run2_iev.txt')
    save_regr(df_run2_iev_regressor,run2_iev_regressor_filename)
    # Run 3
    df_run3_iev_regressor = pomdp_resp_regr(df_run3,df_run3['iev_norm'])
    run3_iev_regressor_filename = os.path.join(cursub_output_folder,'run3_iev.txt')
    save_regr(df_run3_iev_regressor,run3_iev_regressor_filename)
    # Run 4
    df_run4_iev_regressor = pomdp_resp_regr(df_run4,df_run4['iev_norm'])
    run4_iev_regressor_filename = os.path.join(cursub_output_folder,'run4_iev.txt')
    save_regr(df_run4_iev_regressor,run4_iev_regressor_filename)
    
    
    # DF for rel_IEV and IEV_dev activation as an instantaneous regressor ##tsm
    # Run 1
    df_run1_rel_iev_regressor = pomdp_resp_regr(df_run1,df_run1['rel_iev_norm'])
    run1_rel_iev_regressor_filename = os.path.join(cursub_output_folder,'run1_rel_iev.txt')
    save_regr(df_run1_rel_iev_regressor,run1_rel_iev_regressor_filename)
    # Run 2
    df_run2_rel_iev_regressor = pomdp_resp_regr(df_run2,df_run2['rel_iev_norm'])
    run2_rel_iev_regressor_filename = os.path.join(cursub_output_folder,'run2_rel_iev.txt')
    save_regr(df_run2_rel_iev_regressor,run2_rel_iev_regressor_filename)
    # Run 3
    df_run3_rel_iev_regressor = pomdp_resp_regr(df_run3,df_run3['rel_iev_norm'])
    run3_rel_iev_regressor_filename = os.path.join(cursub_output_folder,'run3_rel_iev.txt')
    save_regr(df_run3_rel_iev_regressor,run3_rel_iev_regressor_filename)
    # Run 4
    df_run4_rel_iev_regressor = pomdp_resp_regr(df_run4,df_run4['rel_iev_norm'])
    run4_rel_iev_regressor_filename = os.path.join(cursub_output_folder,'run4_rel_iev.txt')
    save_regr(df_run4_rel_iev_regressor,run4_rel_iev_regressor_filename)
    
    # DF for FEV activation as an instantaneous regressor
    # Run 1
    df_run1_fev_regressor = pomdp_resp_regr(df_run1,df_run1['fev_norm'])
    run1_fev_regressor_filename = os.path.join(cursub_output_folder,'run1_fev.txt')
    save_regr(df_run1_fev_regressor,run1_fev_regressor_filename)
    # Run 2
    df_run2_fev_regressor = pomdp_resp_regr(df_run2,df_run2['fev_norm'])
    run2_fev_regressor_filename = os.path.join(cursub_output_folder,'run2_fev.txt')
    save_regr(df_run2_fev_regressor,run2_fev_regressor_filename)
    # Run 3
    df_run3_fev_regressor = pomdp_resp_regr(df_run3,df_run3['fev_norm'])
    run3_fev_regressor_filename = os.path.join(cursub_output_folder,'run3_fev.txt')
    save_regr(df_run3_fev_regressor,run3_fev_regressor_filename)
    # Run 4
    df_run4_fev_regressor = pomdp_resp_regr(df_run4,df_run4['fev_norm'])
    run4_fev_regressor_filename = os.path.join(cursub_output_folder,'run4_fev.txt')
    save_regr(df_run4_fev_regressor,run4_fev_regressor_filename)
    
    # DF for BONUS activation as an instantaneous regressor
    # Run 1
    df_run1_bonus_regressor = pomdp_resp_regr(df_run1,df_run1['bonus_norm'])
    run1_bonus_regressor_filename = os.path.join(cursub_output_folder,'run1_bonus.txt')
    save_regr(df_run1_bonus_regressor,run1_bonus_regressor_filename)
    # Run 2
    df_run2_bonus_regressor = pomdp_resp_regr(df_run2,df_run2['bonus_norm'])
    run2_bonus_regressor_filename = os.path.join(cursub_output_folder,'run2_bonus.txt')
    save_regr(df_run2_bonus_regressor,run2_bonus_regressor_filename)
    # Run 3
    df_run3_bonus_regressor = pomdp_resp_regr(df_run3,df_run3['bonus_norm'])
    run3_bonus_regressor_filename = os.path.join(cursub_output_folder,'run3_bonus.txt')
    save_regr(df_run3_bonus_regressor,run3_bonus_regressor_filename)
    # Run 4
    df_run4_bonus_regressor = pomdp_resp_regr(df_run4,df_run4['bonus_norm'])
    run4_bonus_regressor_filename = os.path.join(cursub_output_folder,'run4_bonus.txt')
    save_regr(df_run4_bonus_regressor,run4_bonus_regressor_filename)
    
    # DF for TRLSNOV activation as an instantaneous regressor
    # Run 1
    df_run1_trlsnov_regressor = pomdp_resp_regr(df_run1,df_run1['trlsnov_norm'])
    run1_trlsnov_regressor_filename = os.path.join(cursub_output_folder,'run1_trlsnov.txt')
    save_regr(df_run1_trlsnov_regressor,run1_trlsnov_regressor_filename)
    # Run 2
    df_run2_trlsnov_regressor = pomdp_resp_regr(df_run2,df_run2['trlsnov_norm'])
    run2_trlsnov_regressor_filename = os.path.join(cursub_output_folder,'run2_trlsnov.txt')
    save_regr(df_run2_trlsnov_regressor,run2_trlsnov_regressor_filename)
    # Run 3
    df_run3_trlsnov_regressor = pomdp_resp_regr(df_run3,df_run3['trlsnov_norm'])
    run3_trlsnov_regressor_filename = os.path.join(cursub_output_folder,'run3_trlsnov.txt')
    save_regr(df_run3_trlsnov_regressor,run3_trlsnov_regressor_filename)
    # Run 4
    df_run4_trlsnov_regressor = pomdp_resp_regr(df_run4,df_run4['trlsnov_norm'])
    run4_trlsnov_regressor_filename = os.path.join(cursub_output_folder,'run4_trlsnov.txt')
    save_regr(df_run4_trlsnov_regressor,run4_trlsnov_regressor_filename)
    
    # DF for PRE-REWARD activation as an instantaneous regressor
    # Run 1
    df_run1_preReward = df_run1[df_run1.prev_outcome!=999]
    df_run1_preReward_regressor = pomdp_resp_regr(df_run1_preReward,df_run1_preReward['prev_outcome'])
    run1_preReward_regressor_filename = os.path.join(cursub_output_folder,'run1_prereward.txt')
    save_regr(df_run1_preReward_regressor,run1_preReward_regressor_filename)
    # Run 2
    df_run2_preReward = df_run2[df_run2.prev_outcome!=999]
    df_run2_preReward_regressor = pomdp_resp_regr(df_run2_preReward,df_run2_preReward['prev_outcome'])
    run2_preReward_regressor_filename = os.path.join(cursub_output_folder,'run2_prereward.txt')
    save_regr(df_run2_preReward_regressor,run2_preReward_regressor_filename)
    # Run 3
    df_run3_preReward = df_run3[df_run3.prev_outcome!=999]
    df_run3_preReward_regressor = pomdp_resp_regr(df_run3_preReward,df_run3_preReward['prev_outcome'])
    run3_preReward_regressor_filename = os.path.join(cursub_output_folder,'run3_prereward.txt')
    save_regr(df_run3_preReward_regressor,run3_preReward_regressor_filename)
    # Run 4
    df_run4_preReward = df_run4[df_run4.prev_outcome!=999]
    df_run4_preReward_regressor = pomdp_resp_regr(df_run4_preReward,df_run4_preReward['prev_outcome'])
    run4_preReward_regressor_filename = os.path.join(cursub_output_folder,'run4_prereward.txt')
    save_regr(df_run4_preReward_regressor,run4_preReward_regressor_filename)
    
    # DF for IEV activation as a variable epoch regressor
    # Run 1
    df_run1_iev_epoch_regressor = pomdp_resp_epoch_regr(df_run1,df_run1['iev_norm'])
    run1_iev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run1_iev_epoch.txt')
    save_regr(df_run1_iev_epoch_regressor,run1_iev_epoch_regressor_filename)
    # Run 2
    df_run2_iev_epoch_regressor = pomdp_resp_epoch_regr(df_run2,df_run2['iev_norm'])
    run2_iev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run2_iev_epoch.txt')
    save_regr(df_run2_iev_epoch_regressor,run2_iev_epoch_regressor_filename)
    # Run 3
    df_run3_iev_epoch_regressor = pomdp_resp_epoch_regr(df_run3,df_run3['iev_norm'])
    run3_iev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run3_iev_epoch.txt')
    save_regr(df_run3_iev_epoch_regressor,run3_iev_epoch_regressor_filename)
    # Run 4
    df_run4_iev_epoch_regressor = pomdp_resp_epoch_regr(df_run4,df_run4['iev_norm'])
    run4_iev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run4_iev_epoch.txt')
    save_regr(df_run4_iev_epoch_regressor,run4_iev_epoch_regressor_filename)
    
    # DF for FEV activation as a variable epoch regressor
    # Run 1
    df_run1_fev_epoch_regressor = pomdp_resp_epoch_regr(df_run1,df_run1['fev_norm'])
    run1_fev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run1_fev_epoch.txt')
    save_regr(df_run1_fev_epoch_regressor,run1_fev_epoch_regressor_filename)
    # Run 2
    df_run2_fev_epoch_regressor = pomdp_resp_epoch_regr(df_run2,df_run2['fev_norm'])
    run2_fev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run2_fev_epoch.txt')
    save_regr(df_run2_fev_epoch_regressor,run2_fev_epoch_regressor_filename)
    # Run 3
    df_run3_fev_epoch_regressor = pomdp_resp_epoch_regr(df_run3,df_run3['fev_norm'])
    run3_fev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run3_fev_epoch.txt')
    save_regr(df_run3_fev_epoch_regressor,run3_fev_epoch_regressor_filename)
    # Run 4
    df_run4_fev_epoch_regressor = pomdp_resp_epoch_regr(df_run4,df_run4['fev_norm'])
    run4_fev_epoch_regressor_filename = os.path.join(cursub_output_folder,'run4_fev_epoch.txt')
    save_regr(df_run4_fev_epoch_regressor,run4_fev_epoch_regressor_filename)
    
    # DF for BONUS activation as a variable epoch regressor
    # Run 1
    df_run1_bonus_epoch_regressor = pomdp_resp_epoch_regr(df_run1,df_run1['bonus_norm'])
    run1_bonus_epoch_regressor_filename = os.path.join(cursub_output_folder,'run1_bonus_epoch.txt')
    save_regr(df_run1_bonus_epoch_regressor,run1_bonus_epoch_regressor_filename)
    # Run 2
    df_run2_bonus_epoch_regressor = pomdp_resp_epoch_regr(df_run2,df_run2['bonus_norm'])
    run2_bonus_epoch_regressor_filename = os.path.join(cursub_output_folder,'run2_bonus_epoch.txt')
    save_regr(df_run2_bonus_epoch_regressor,run2_bonus_epoch_regressor_filename)
    # Run 3
    df_run3_bonus_epoch_regressor = pomdp_resp_epoch_regr(df_run3,df_run3['bonus_norm'])
    run3_bonus_epoch_regressor_filename = os.path.join(cursub_output_folder,'run3_bonus_epoch.txt')
    save_regr(df_run3_bonus_epoch_regressor,run3_bonus_epoch_regressor_filename)
    # Run 4
    df_run4_bonus_epoch_regressor = pomdp_resp_epoch_regr(df_run4,df_run4['bonus_norm'])
    run4_bonus_epoch_regressor_filename = os.path.join(cursub_output_folder,'run4_bonus_epoch.txt')
    save_regr(df_run4_bonus_epoch_regressor,run4_bonus_epoch_regressor_filename)
    
    # DF for TRLSNOV activation as a variable epoch regressor
    # Run 1
    df_run1_trlsnov_epoch_regressor = pomdp_resp_epoch_regr(df_run1,df_run1['trlsnov_norm'])
    run1_trlsnov_epoch_regressor_filename = os.path.join(cursub_output_folder,'run1_trlsnov_epoch.txt')
    save_regr(df_run1_trlsnov_epoch_regressor,run1_trlsnov_epoch_regressor_filename)
    # Run 2
    df_run2_trlsnov_epoch_regressor = pomdp_resp_epoch_regr(df_run2,df_run2['trlsnov_norm'])
    run2_trlsnov_epoch_regressor_filename = os.path.join(cursub_output_folder,'run2_trlsnov_epoch.txt')
    save_regr(df_run2_trlsnov_epoch_regressor,run2_trlsnov_epoch_regressor_filename)
    # Run 3
    df_run3_trlsnov_epoch_regressor = pomdp_resp_epoch_regr(df_run3,df_run3['trlsnov_norm'])
    run3_trlsnov_epoch_regressor_filename = os.path.join(cursub_output_folder,'run3_trlsnov_epoch.txt')
    save_regr(df_run3_trlsnov_epoch_regressor,run3_trlsnov_epoch_regressor_filename)
    # Run 4
    df_run4_trlsnov_epoch_regressor = pomdp_resp_epoch_regr(df_run4,df_run4['trlsnov_norm'])
    run4_trlsnov_epoch_regressor_filename = os.path.join(cursub_output_folder,'run4_trlsnov_epoch.txt')
    save_regr(df_run4_trlsnov_epoch_regressor,run4_trlsnov_epoch_regressor_filename)
    
    # DF for PRE-REWARD activation as a variable epoch regressor
    # Run 1
    df_run1_preReward = df_run1[df_run1.prev_outcome!=999]
    df_run1_preReward_epoch_regressor = pomdp_resp_epoch_regr(df_run1_preReward,df_run1_preReward['prev_outcome'])
    run1_preReward_epoch_regressor_filename = os.path.join(cursub_output_folder,'run1_prereward_epoch.txt')
    save_regr(df_run1_preReward_epoch_regressor,run1_preReward_epoch_regressor_filename)
    # Run 2
    df_run2_preReward = df_run2[df_run2.prev_outcome!=999]
    df_run2_preReward_epoch_regressor = pomdp_resp_epoch_regr(df_run2_preReward,df_run2_preReward['prev_outcome'])
    run2_preReward_epoch_regressor_filename = os.path.join(cursub_output_folder,'run2_prereward_epoch.txt')
    save_regr(df_run2_preReward_epoch_regressor,run2_preReward_epoch_regressor_filename)
    # Run 3
    df_run3_preReward = df_run3[df_run3.prev_outcome!=999]
    df_run3_preReward_epoch_regressor = pomdp_resp_epoch_regr(df_run3_preReward,df_run3_preReward['prev_outcome'])
    run3_preReward_epoch_regressor_filename = os.path.join(cursub_output_folder,'run3_prereward_epoch.txt')
    save_regr(df_run3_preReward_epoch_regressor,run3_preReward_epoch_regressor_filename)
    # Run 4
    df_run4_preReward = df_run4[df_run4.prev_outcome!=999]
    df_run4_preReward_epoch_regressor = pomdp_resp_epoch_regr(df_run4_preReward,df_run4_preReward['prev_outcome'])
    run4_preReward_epoch_regressor_filename = os.path.join(cursub_output_folder,'run4_prereward_epoch.txt')
    save_regr(df_run4_preReward_epoch_regressor,run4_preReward_epoch_regressor_filename)
    
    # DF for RPE activation as an instantaneous regressor
    # Run 1
    df_run1_rpe_regressor = pomdp_outcome_regr(df_run1,df_run1['pred_err_norm'])
    run1_rpe_regressor_filename = os.path.join(cursub_output_folder,'run1_rpe.txt')
    save_regr(df_run1_rpe_regressor,run1_rpe_regressor_filename)
    # Run 2
    df_run2_rpe_regressor = pomdp_outcome_regr(df_run2,df_run2['pred_err_norm'])
    run2_rpe_regressor_filename = os.path.join(cursub_output_folder,'run2_rpe.txt')
    save_regr(df_run2_rpe_regressor,run2_rpe_regressor_filename)
    # Run 3
    df_run3_rpe_regressor = pomdp_outcome_regr(df_run3,df_run3['pred_err_norm'])
    run3_rpe_regressor_filename = os.path.join(cursub_output_folder,'run3_rpe.txt')
    save_regr(df_run3_rpe_regressor,run3_rpe_regressor_filename)
    # Run 4
    df_run4_rpe_regressor = pomdp_outcome_regr(df_run4,df_run4['pred_err_norm'])
    run4_rpe_regressor_filename = os.path.join(cursub_output_folder,'run4_rpe.txt')
    save_regr(df_run4_rpe_regressor,run4_rpe_regressor_filename)