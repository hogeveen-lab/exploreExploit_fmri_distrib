#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Explore-Exploit fMRI: Neuron Paper
Generating pomdp-based design files
notes: Main code product are files *modelbased.fsf in each participants' FSL folder
notes: 7b and 7d represent the run-level and subject-level FSL design file templates
notes: To skip FSL registration (e.g. if data are preprocessed in fmriprep), run code 7c IN BETWEEN run-level and subj-level FEATs
author: jeremy hogeveen (jhogeveen@unm.edu)
last edit: March 9, 2021
"""

#%% Chunk 1: Importing packages and setting up the files we need
# Package import
from glob import glob
import os
import shutil
import numpy as np
import pandas as pd
import re
import ntpath
import nibabel as nib

# base directory
base = 'PATHPATHPATHPATH' # base directory on local machine
wheeler_base = 'PATHPATHPATHPATH' # base directory where you will be running FEAT models (kept separate for use on HPC)

# using func runs to kick things off
func_path = os.path.join(base,'fmriprep/fmriprep/sub-p*/func/*bandit_run-*_space-MNI152NLin2009cAsym_desc-preproc_bold.nii.gz')

# where do we want to save the outputs?
fsl_dir = os.path.join(base,'fsl')
wheeler_fsl_dir = os.path.join(wheeler_base,'fsl')

# where are the regressors saved?
regr_dir = os.path.join(base,'regressors_final')
wheeler_regr_dir = os.path.join(wheeler_base,'regressors_final')

# fsl MNI template dir
mni_template = '/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz'
wheeler_mni_template = os.path.join(wheeler_fsl_dir,'fsl_scripts/MNI152_T1_2mm_brain.nii.gz')
                                 
# wheeler FLOBs
wheeler_flobs = os.path.join(wheeler_fsl_dir,'fsl_scripts/default_flobs.flobs/hrfbasisfns.txt')

# fsl design templates
runlevel_modelbased_template = os.path.join(base,'7b_fmri_run_modelbased_wconstant.fsf')

# fsl template find lines
modelbased_findlines = ('XXX_OUTDIR_XXX','XXX_NUMVOLS_XXX','XXX_TEMPLATE_XXX','XXX_FLOBS_XXX','XXX_FUNC_XXX','XXX_CONFOUNDS_XXX','XXX_IEV_XXX','XXX_FEV_XXX','XXX_BONUS_XXX','XXX_TRLSNOV_XXX','XXX_PREREWARD_XXX','XXX_RPE_XXX','XXX_CONSTANT_XXX')

# creating a list of the func files
allfiles = glob(func_path)

# setting up a function to replace text in design files
def replace_text(template,out_design,dictionary):
    with open(template) as data:
        with open(out_design,'w') as new_data:
            for line in data:
                for key in dictionary:
                    if key in line:
                        line = line.replace(key,dictionary[key])
                new_data.write(line)
#%%

#%% Chunk 2: Creating run-level design files for each participant
for i in range(0,len(allfiles)):
    
    ### Step 1: Loading the data and generating current subject, runid, and # of vols
    # pulling pid from filename using regex
    func_filename = allfiles[i]
    curfile = ntpath.basename(func_filename)
    pid = re.compile('^[^_]*[^ _]')
    bidsid = pid.findall(curfile)[0]
    shortid = bidsid.replace("sub-p", "P", 3)
    # pulling runnum from filename using regex
    rundigit = re.search(r'run-(\d+)',curfile).group(1)
    bidsrun = 'run-'+rundigit
    shortrun = 'run'+rundigit
   # opening the current nifti image to find its number of volumes
    func_file = nib.load(func_filename)
    func_header = func_file.header
    # creating an fsl dir for the subject if none exists yet
    cursub_outdir = os.path.join(fsl_dir,bidsid)
    wheeler_cursub_outdir = os.path.join(wheeler_fsl_dir,bidsid)
    if not os.path.exists(cursub_outdir):
        os.makedirs(cursub_outdir)
    
    ### Step 2: Setting the information to be replaced in the MODEL_BASED design file
    # XXX_OUTDIR_XXX
    model_currun_outdir = os.path.join(wheeler_cursub_outdir,bidsrun+'_modelbased_wconstant.feat')
    model_currun_design = os.path.join(cursub_outdir,bidsrun+'_modelbased_wconstant.fsf')
    # XXX_NUMVOLS_XXX
    numvols = func_header['dim'][4]
    # XXX_CONFOUNDS_XXX
    wheeler_func_filename = func_filename.replace(base,wheeler_base)
    confounds = os.path.join(os.path.dirname(wheeler_func_filename),bidsid+'_task-bandit_'+bidsrun+'_desc-confounds_filt.txt')
    
    # XXX_IEV_XXX
    iev = os.path.join(wheeler_regr_dir,shortid,shortrun+'_iev.txt')
    # XXX_FEV_XXX
    fev = os.path.join(wheeler_regr_dir,shortid,shortrun+'_fev.txt')
    # XXX_BONUS_XXX
    bonus = os.path.join(wheeler_regr_dir,shortid,shortrun+'_bonus.txt')
    # XXX_TRLSNOV_XXX
    trlsnov = os.path.join(wheeler_regr_dir,shortid,shortrun+'_trlsnov.txt')
    # XXX_PREREWARD_XXX
    prereward = os.path.join(wheeler_regr_dir,shortid,shortrun+'_prereward.txt')
    # XXX_RPE_XXX
    rpe = os.path.join(wheeler_regr_dir,shortid,shortrun+'_rpe.txt')
    # XXX_CONSTANT_XXX
    constant = os.path.join(wheeler_regr_dir,shortid,shortrun+'_choice_mean.txt')
    
    ### Step 3: Reading and replacing text in the MODEL-BASED design file
   # printing a msg for the user
    print('generating fsl model-based design files for:',bidsid,bidsrun)
    # replace lines dictionary
    model_replacelines = (model_currun_outdir,str(numvols),wheeler_mni_template,wheeler_flobs,wheeler_func_filename,confounds,iev,fev,bonus,trlsnov,prereward,rpe,constant)
    model_find_replace = dict(zip(modelbased_findlines,model_replacelines))
    # reading in the data and making the replacements
    replace_text(runlevel_modelbased_template,model_currun_design,model_find_replace)
#%%

#%% Chunk 3: Creating subject-level design files for each participant

# using sub folders
sub_folder = os.path.join(fsl_dir,'sub-p*')

# whta lines to replace
sublevel_findlines = ('XXX_OUTDIR_XXX','XXX_RUN1_XXX','XXX_RUN2_XXX','XXX_RUN3_XXX','XXX_RUN4_XXX')

# creating a list of the func files
allsubs = glob(sub_folder)

# allruns template files
sublevel_modelbased_template = os.path.join(base,'7d_fmri_sub_modelbased_final.fsf')

# looping through and generating the sub-level design files
for i in range(0,len(allsubs)):
    
    ### Step 1: Loading the data and generating current subject, runid, and # of vols
    # pulling pid from filename using regex
    sub_dir = allsubs[i]
    curfile = ntpath.basename(sub_dir)
    pid = re.compile('^[^_]*[^ _]')
    bidsid = pid.findall(curfile)[0]
    # creating an fsl dir for the subject if none exists yet
    cursub_outdir = os.path.join(fsl_dir,bidsid)
    wheeler_cursub_outdir = os.path.join(wheeler_fsl_dir,bidsid)
    if not os.path.exists(cursub_outdir):
        os.makedirs(cursub_outdir)
    
    ### Step 2: Setting the information to be replaced in the MODEL_BASED design file
    # XXX_OUTDIR_XXX
    modelbased_allruns_cursub_outdir = os.path.join(wheeler_cursub_outdir,'allruns_modelbased_wconstant.gfeat')
    modelbased_allruns_cursub_design = os.path.join(cursub_outdir,'allruns_modelbased_wconstant.fsf')
    # XXX_RUN#_XXX
    modelbased_run1 = os.path.join(cursub_outdir,'run-1_modelbased_wconstant.feat')
    modelbased_run2 = os.path.join(cursub_outdir,'run-2_modelbased_wconstant.feat')
    modelbased_run3 = os.path.join(cursub_outdir,'run-3_modelbased_wconstant.feat')
    modelbased_run4 = os.path.join(cursub_outdir,'run-4_modelbased_wconstant.feat')
    
    ### Step 3: Reading and replacing text in the MODEL-BASED design file
   # printing a msg for the user
    print('generating fsl modelbased-related allruns design files for:',bidsid)
    # replace lines dictionary
    modelbased_allruns_replacelines = (modelbased_allruns_cursub_outdir,
                                       modelbased_run1,
                                       modelbased_run2,
                                       modelbased_run3,
                                       modelbased_run4)
    modelbased_allruns_find_replace = dict(zip(sublevel_findlines,modelbased_allruns_replacelines))
    # reading in the data and making the replacements
    replace_text(sublevel_modelbased_template,modelbased_allruns_cursub_design,modelbased_allruns_find_replace)

#%%