##### Random functions for later use ##### 
##### By: Jeremy Hogeveen (jeremy.hogeveen@gmail.com)
##### Date: March 9, 2022

##### Cohen's D from paired t-tests #####
paired_d <- function(x,y){
  x_col <- x
  y_col  <- y
  Difference <- (x_col - y_col)
  print(cohenD <- ( mean(x_col) - mean(y_col) ) / sd(Difference))
}

##### RBS-R factor solution functions ##### 
rbsr_STD = function(df) { #standard 6-factor solution via Bodfish et al., 2000
  df <- df %>%
    mutate(rbsSTD_SIB = rbsr_7 + rbsr_8 + rbsr_9 + rbsr_10 + rbsr_11 + rbsr_12 + rbsr_13 + rbsr_14) %>%
    mutate(rbsSTD_STB = rbsr_1 + rbsr_2 + rbsr_3 + rbsr_4 + rbsr_5 + rbsr_6) %>%
    mutate(rbsSTD_REB = rbsr_40 + rbsr_41 + rbsr_42 + rbsr_43) %>%
    mutate(rbsSTD_CB = rbsr_15 + rbsr_16 + rbsr_17 + rbsr_18 + rbsr_19 + rbsr_20 + rbsr_21 + rbsr_22) %>%
    mutate(rbsSTD_RIB = rbsr_23 + rbsr_24 + rbsr_25 + rbsr_26 + rbsr_27 + rbsr_28 ) %>%
    mutate(rbsSTD_SAB = rbsr_29 + rbsr_30 + rbsr_31 + rbsr_32 + rbsr_33 + rbsr_34 + rbsr_35 + rbsr_36 + rbsr_37 + rbsr_38 + rbsr_39) %>%
    mutate(rbsSTD_TOT = rbsSTD_SIB + rbsSTD_STB + rbsSTD_REB + rbsSTD_CB + rbsSTD_RIB + rbsSTD_SAB)
}

rbsr_3 = function(df) { # 3-factor solution via Mirenda et al. 2010
  df <- df %>%
    mutate(rbs3_SIB = rbsr_7 + rbsr_8 + rbsr_9 + rbsr_10 + rbsr_11 + rbsr_12 + rbsr_13 + rbsr_14) %>%
    mutate(rbs3_STB_REB = rbsr_1 + rbsr_2 + rbsr_3 + rbsr_4 + rbsr_5 + rbsr_6 + rbsr_40 + rbsr_41 + rbsr_42 + rbsr_43) %>%
    mutate(rbs3_CB_RIB_SAB = rbsr_15 + rbsr_16 + rbsr_17 + rbsr_18 + rbsr_19 + rbsr_20 + rbsr_21 + rbsr_22 + rbsr_23 + rbsr_24 + rbsr_25 + rbsr_26 + rbsr_27 + rbsr_28 + rbsr_29 + rbsr_30 + rbsr_31 + rbsr_32 + rbsr_33 + rbsr_34 + rbsr_35 + rbsr_36 + rbsr_37 + rbsr_38 + rbsr_39) %>%
    mutate(rbs3_TOT = rbs3_SIB + rbs3_STB_REB + rbs3_CB_RIB_SAB)
}

rbsr_5_mirenda = function(df) { # 5-factor solution via Mirenda et al. 2010
  df <- df %>%
    mutate(rbs5_STB = rbsr_1 + rbsr_2 + rbsr_3 + rbsr_4 + rbsr_5 + rbsr_6) %>%
    mutate(rbs5_SIB = rbsr_7 + rbsr_8 + rbsr_9 + rbsr_10 + rbsr_11 + rbsr_12 + rbsr_13 + rbsr_14) %>%
    mutate(rbs5_CB = rbsr_15 + rbsr_16 + rbsr_17 + rbsr_18 + rbsr_19 + rbsr_20 + rbsr_21 + rbsr_22) %>%
    mutate(rbs5_RIB_SAB = rbsr_23 + rbsr_24 + rbsr_25 + rbsr_26 + rbsr_27 + rbsr_28 + rbsr_29 + rbsr_30 + rbsr_31 + rbsr_32 + rbsr_33 + rbsr_34 + rbsr_35 + rbsr_36 + rbsr_37 + rbsr_38 + rbsr_39) %>%
    mutate(rbs5_REB = rbsr_40 + rbsr_41 + rbsr_42 + rbsr_43) %>%
    mutate(rbs5_TOT = rbs5_STB + rbs5_SIB + rbs5_CB + rbs5_RIB_SAB + rbs5_REB)
}
rbsr_5 = function(df) { # 5-factor solution via Lam & Aman, 2007
  df <- df %>%
    mutate(rbs5_STB = rbsr_1 + rbsr_2 + rbsr_3 + rbsr_4 + rbsr_5 + rbsr_6 + rbsr_22  + rbsr_42 + rbsr_43) %>%
    mutate(rbs5_SIB = rbsr_7 + rbsr_8 + rbsr_9 + rbsr_10 + rbsr_11 + rbsr_12 + rbsr_13 + rbsr_14) %>%
    mutate(rbs5_CB = rbsr_15 + rbsr_16 + rbsr_17 + rbsr_18 + rbsr_19 + rbsr_20) %>%
    mutate(rbs5_RIB_SAB = rbsr_26 + rbsr_27 + rbsr_28 + rbsr_29 + rbsr_30 + rbsr_31 + rbsr_32 + rbsr_33 + rbsr_34 + rbsr_35 + rbsr_36 + rbsr_37 + rbsr_38 + rbsr_39) %>%
    mutate(rbs5_REB = rbsr_36 + rbsr_40 + rbsr_41)%>%
    mutate(rbs5_TOT = rbs5_STB + rbs5_SIB + rbs5_CB + rbs5_RIB_SAB + rbs5_REB)
}

##### TAS (Toronto Alexithymia Scale; Bagby et al.) ##### 
tas_20_3factor <- function(df) {
  df <- df %>%
    mutate(TAS20Q_004_rev=ifelse(as.numeric(TAS20Q_004)==1,5,ifelse(as.numeric(TAS20Q_004)==2,4,ifelse(as.numeric(TAS20Q_004)==3,3,ifelse(as.numeric(TAS20Q_004)==4,2,ifelse(as.numeric(TAS20Q_004)==5,1,"")))))) %>%
    mutate(TAS20Q_005_rev=ifelse(as.numeric(TAS20Q_005)==1,5,ifelse(as.numeric(TAS20Q_005)==2,4,ifelse(as.numeric(TAS20Q_005)==3,3,ifelse(as.numeric(TAS20Q_005)==4,2,ifelse(as.numeric(TAS20Q_005)==5,1,"")))))) %>%
    mutate(TAS20Q_010_rev=ifelse(as.numeric(TAS20Q_010)==1,5,ifelse(as.numeric(TAS20Q_010)==2,4,ifelse(as.numeric(TAS20Q_010)==3,3,ifelse(as.numeric(TAS20Q_010)==4,2,ifelse(as.numeric(TAS20Q_010)==5,1,"")))))) %>%
    mutate(TAS20Q_018_rev=ifelse(as.numeric(TAS20Q_018)==1,5,ifelse(as.numeric(TAS20Q_018)==2,4,ifelse(as.numeric(TAS20Q_018)==3,3,ifelse(as.numeric(TAS20Q_018)==4,2,ifelse(as.numeric(TAS20Q_018)==5,1,"")))))) %>%
    mutate(TAS20Q_019_rev=ifelse(as.numeric(TAS20Q_019)==1,5,ifelse(as.numeric(TAS20Q_019)==2,4,ifelse(as.numeric(TAS20Q_019)==3,3,ifelse(as.numeric(TAS20Q_019)==4,2,ifelse(as.numeric(TAS20Q_019)==5,1,"")))))) %>%
    mutate(tas_dif = as.numeric(TAS20Q_001) + as.numeric(TAS20Q_003) + as.numeric(TAS20Q_006) + as.numeric(TAS20Q_007) + as.numeric(TAS20Q_009) + as.numeric(TAS20Q_013) + as.numeric(TAS20Q_014)) %>%
    mutate(tas_ddf = as.numeric(TAS20Q_002) + as.numeric(TAS20Q_004_rev) + as.numeric(TAS20Q_011) + as.numeric(TAS20Q_012) + as.numeric(TAS20Q_017)) %>%
    mutate(tas_exo = as.numeric(TAS20Q_005_rev) + as.numeric(TAS20Q_008) + as.numeric(TAS20Q_010_rev) + as.numeric(TAS20Q_015) + as.numeric(TAS20Q_016) + as.numeric(TAS20Q_018_rev) + as.numeric(TAS20Q_019_rev) + as.numeric(TAS20Q_020)) %>%
    mutate(tas_tot=tas_dif+tas_ddf+tas_exo) %>%
    mutate(tas_grp=ifelse(tas_tot>=61,3,ifelse(tas_tot>51,2,ifelse(tas_tot<=51,1,999))))
}

##### BAI (Beck Anxiety Inventory; Beck et al.) ##### 
bai_21_2factor <- function(df) {
  df <- df %>%
    mutate(bai_som = as.numeric(BAINV_001) + as.numeric(BAINV_002) + as.numeric(BAINV_003) + as.numeric(BAINV_006) + as.numeric(BAINV_007) + as.numeric(BAINV_008) + as.numeric(BAINV_012) + as.numeric(BAINV_013) + as.numeric(BAINV_017) + as.numeric(BAINV_019) + as.numeric(BAINV_020) + as.numeric(BAINV_021)) %>%
    mutate(bai_cog = as.numeric(BAINV_004) + as.numeric(BAINV_005) + as.numeric(BAINV_009) + as.numeric(BAINV_010) + as.numeric(BAINV_011) + as.numeric(BAINV_014) + as.numeric(BAINV_015) + as.numeric(BAINV_016) + as.numeric(BAINV_018)) %>%
    mutate(bai_tot = bai_som + bai_cog) %>%
    mutate(bai_grp = ifelse(bai_tot>=36,3,ifelse(bai_tot>=22,2,ifelse(bai_tot<=21,1,999))))
}

##### BDI (Beck Depression Inventory; Beck et al.) ##### 
bdi_21_2factor <- function(df) {
  df <- df %>%
    mutate(bdi_som = as.numeric(BDINV_001) + as.numeric(BDINV_004) + as.numeric(BDINV_012) + as.numeric(BDINV_013) + as.numeric(BDINV_015) + as.numeric(BDINV_016) + as.numeric(BDINV_017) + as.numeric(BDINV_018) + as.numeric(BDINV_019) + as.numeric(BDINV_020) + as.numeric(BDINV_021)) %>%
    mutate(bdi_cog = as.numeric(BDINV_002) + as.numeric(BDINV_003) + as.numeric(BDINV_005) + as.numeric(BDINV_006) + as.numeric(BDINV_007) + as.numeric(BDINV_008) + as.numeric(BDINV_009) + as.numeric(BDINV_010) + as.numeric(BDINV_011) + as.numeric(BDINV_014)) %>%
    mutate(bdi_tot = bdi_som + bdi_cog) %>%
    mutate(bdi_grp = ifelse(bdi_tot>=29,4,ifelse(bdi_tot>=20,3,ifelse(bdi_tot>=14,2,ifelse(bdi_tot<=13,1,999)))))
}

##### BIS (Barratt Impulsivity Scale; Barratt et al.) ##### 
bis_30_3factor <- function(df) {
  df <- df %>%
    mutate(BIQ00_001_rev = ifelse(BIQ00_001=='4',1,ifelse(BIQ00_001=='3',2,ifelse(BIQ00_001=='2',3,ifelse(BIQ00_001=='1',4,999))))) %>%
    mutate(BIQ00_007_rev = ifelse(BIQ00_007=='4',1,ifelse(BIQ00_007=='3',2,ifelse(BIQ00_007=='2',3,ifelse(BIQ00_007=='1',4,999))))) %>%
    mutate(BIQ00_008_rev = ifelse(BIQ00_008=='4',1,ifelse(BIQ00_008=='3',2,ifelse(BIQ00_008=='2',3,ifelse(BIQ00_008=='1',4,999))))) %>%
    mutate(BIQ00_009_rev = ifelse(BIQ00_009=='4',1,ifelse(BIQ00_009=='3',2,ifelse(BIQ00_009=='2',3,ifelse(BIQ00_009=='1',4,999))))) %>%
    mutate(BIQ00_010_rev = ifelse(BIQ00_010=='4',1,ifelse(BIQ00_010=='3',2,ifelse(BIQ00_010=='2',3,ifelse(BIQ00_010=='1',4,999))))) %>%
    mutate(BIQ00_012_rev = ifelse(BIQ00_012=='4',1,ifelse(BIQ00_012=='3',2,ifelse(BIQ00_012=='2',3,ifelse(BIQ00_012=='1',4,999))))) %>%
    mutate(BIQ00_013_rev = ifelse(BIQ00_013=='4',1,ifelse(BIQ00_013=='3',2,ifelse(BIQ00_013=='2',3,ifelse(BIQ00_013=='1',4,999))))) %>%
    mutate(BIQ00_015_rev = ifelse(BIQ00_015=='4',1,ifelse(BIQ00_015=='3',2,ifelse(BIQ00_015=='2',3,ifelse(BIQ00_015=='1',4,999))))) %>%
    mutate(BIQ00_020_rev = ifelse(BIQ00_020=='4',1,ifelse(BIQ00_020=='3',2,ifelse(BIQ00_020=='2',3,ifelse(BIQ00_020=='1',4,999))))) %>%
    mutate(BIQ00_029_rev = ifelse(BIQ00_029=='4',1,ifelse(BIQ00_029=='3',2,ifelse(BIQ00_029=='2',3,ifelse(BIQ00_029=='1',4,999))))) %>%
    mutate(BIQ00_030_rev = ifelse(BIQ00_030=='4',1,ifelse(BIQ00_030=='3',2,ifelse(BIQ00_030=='2',3,ifelse(BIQ00_030=='1',4,999))))) %>%
    mutate(bis_noplan = BIQ00_001_rev + BIQ00_007_rev + BIQ00_008_rev + BIQ00_010_rev + BIQ00_012_rev + BIQ00_013_rev + as.numeric(BIQ00_014) + BIQ00_015_rev + as.numeric(BIQ00_018) + as.numeric(BIQ00_027) + BIQ00_029_rev) %>%
    mutate(bis_noplan_selfCtrl = BIQ00_001_rev + BIQ00_007_rev + BIQ00_008_rev + BIQ00_012_rev + BIQ00_013_rev + as.numeric(BIQ00_014)) %>%
    mutate(bis_noplan_cogCmplx = BIQ00_010_rev + BIQ00_015_rev + as.numeric(BIQ00_018) + as.numeric(BIQ00_027) + BIQ00_029_rev) %>%
    mutate(bis_attn = as.numeric(BIQ00_005) + as.numeric(BIQ00_006) + BIQ00_009_rev + as.numeric(BIQ00_011) + BIQ00_020_rev + as.numeric(BIQ00_024) + as.numeric(BIQ00_026) + as.numeric(BIQ00_028)) %>%
    mutate(bis_attn_attn = as.numeric(BIQ00_005) + BIQ00_009_rev + as.numeric(BIQ00_011) + BIQ00_020_rev + as.numeric(BIQ00_028)) %>%
    mutate(bis_attn_cogInst = as.numeric(BIQ00_006) + as.numeric(BIQ00_024) + as.numeric(BIQ00_026)) %>%
    mutate(bis_mot = as.numeric(BIQ00_002) + as.numeric(BIQ00_003) + as.numeric(BIQ00_004) + as.numeric(BIQ00_016) + as.numeric(BIQ00_017) + as.numeric(BIQ00_019) + as.numeric(BIQ00_021) + as.numeric(BIQ00_022) + as.numeric(BIQ00_023) + as.numeric(BIQ00_025) + BIQ00_030_rev) %>%
    mutate(bis_mot_mot = as.numeric(BIQ00_002) + as.numeric(BIQ00_003) + as.numeric(BIQ00_004) + as.numeric(BIQ00_017) + as.numeric(BIQ00_019) + as.numeric(BIQ00_022) +  as.numeric(BIQ00_025)) %>%
    mutate(bis_mot_pers = as.numeric(BIQ00_016) + as.numeric(BIQ00_021) + as.numeric(BIQ00_023) + BIQ00_030_rev) %>%
    mutate(bis_tot = bis_noplan+bis_attn+bis_mot) %>%
    mutate(bis_grp = ifelse(bis_tot > 60, 1,0))
}

##### Padua Inventory â€“ Washington State University Revision (Burns et al., 1996) #####
padua_39_5factor <- function(df) {
  df <- df %>%
    mutate(padua_contamination = as.numeric(PADUA00_001) + as.numeric(PADUA00_002) + as.numeric(PADUA00_003) + as.numeric(PADUA00_004) + as.numeric(PADUA00_005) + as.numeric(PADUA00_006) + as.numeric(PADUA00_007) + as.numeric(PADUA00_008) + as.numeric(PADUA00_009) + as.numeric(PADUA00_010)) %>%
    mutate(padua_grooming = as.numeric(PADUA00_011) + as.numeric(PADUA00_012) + as.numeric(PADUA00_013)) %>%
    mutate(padua_checking = as.numeric(PADUA00_014) + as.numeric(PADUA00_015) + as.numeric(PADUA00_016) + as.numeric(PADUA00_017) + as.numeric(PADUA00_018) + as.numeric(PADUA00_019) + as.numeric(PADUA00_020) + as.numeric(PADUA00_021) + as.numeric(PADUA00_022) + as.numeric(PADUA00_023)) %>%
    mutate(padua_thoughts = as.numeric(PADUA00_024) + as.numeric(PADUA00_025) + as.numeric(PADUA00_026) + as.numeric(PADUA00_027) + as.numeric(PADUA00_028) + as.numeric(PADUA00_029) + as.numeric(PADUA00_030)) %>%
    mutate(padua_impulses = as.numeric(PADUA00_031) + as.numeric(PADUA00_032) + as.numeric(PADUA00_033) + as.numeric(PADUA00_034) + as.numeric(PADUA00_035) + as.numeric(PADUA00_036) + as.numeric(PADUA00_037) + as.numeric(PADUA00_038) + as.numeric(PADUA00_039)) %>%
    mutate(padua_total = padua_contamination+padua_grooming+padua_checking+padua_thoughts+padua_impulses)
}

##### Meta Cognitions Questionnaire - 30 (Wells & Cartwright-hatton, 2004) #####
mcq_30_5factor <- function(df) {
  df <- df %>%
    mutate(mcq_positive = as.numeric(MCQ30JH_001) + as.numeric(MCQ30JH_007) + as.numeric(MCQ30JH_010) + as.numeric(MCQ30JH_019) + as.numeric(MCQ30JH_023) + as.numeric(MCQ30JH_028)) %>%
    mutate(mcq_negative = as.numeric(MCQ30JH_002) + as.numeric(MCQ30JH_004) + as.numeric(MCQ30JH_111) + as.numeric(MCQ30JH_011) + as.numeric(MCQ30JH_015) + as.numeric(MCQ30JH_021)) %>%
    mutate(mcq_confidence = as.numeric(MCQ30JH_008) + as.numeric(MCQ30JH_014) + as.numeric(MCQ30JH_017) + as.numeric(MCQ30JH_024) + as.numeric(MCQ30JH_026) + as.numeric(MCQ30JH_029)) %>%
    mutate(mcq_control = as.numeric(MCQ30JH_006) + as.numeric(MCQ30JH_013) + as.numeric(MCQ30JH_020) + as.numeric(MCQ30JH_022) + as.numeric(MCQ30JH_025) + as.numeric(MCQ30JH_027)) %>%
    mutate(mcq_selfconsc = as.numeric(MCQ30JH_003) + as.numeric(MCQ30JH_005) + as.numeric(MCQ30JH_012) + as.numeric(MCQ30JH_016) + as.numeric(MCQ30JH_018) + as.numeric(MCQ30JH_030)) %>%
    mutate(mcq_tot = mcq_positive+mcq_negative+mcq_confidence+mcq_control+mcq_selfconsc)
}

##### Autism Quotient Scoring -- based on Baron-Cohen et al., 2001) #####
aq_50_5factors <- function(df) {
  df <- df %>%
    mutate(AQ1= ifelse(as.numeric(AQJH_001)>=3,1,0),AQ3=ifelse(as.numeric(AQJH_003)>=3,1,0),AQ8=ifelse(as.numeric(AQJH_008)>=3,1,0),AQ10=ifelse(as.numeric(AQJH_010)>=3,1,0),AQ11=ifelse(as.numeric(AQJH_011)>=3,1,0), #5
         AQ14=ifelse(as.numeric(AQJH_014)>=3,1,0),AQ15=ifelse(as.numeric(AQJH_015)>=3,1,0),AQ17=ifelse(as.numeric(AQJH_017)>=3,1,0),AQ24=ifelse(as.numeric(AQJH_024)>=3,1,0),AQ25=ifelse(as.numeric(AQJH_025)>=3,1,0), #5
         AQ27=ifelse(as.numeric(AQJH_027)>=3,1,0),AQ28=ifelse(as.numeric(AQJH_028)>=3,1,0),AQ29=ifelse(as.numeric(AQJH_029)>=3,1,0),AQ30=ifelse(as.numeric(AQJH_030)>=3,1,0),AQ31=ifelse(as.numeric(AQJH_031)>=3,1,0), #5
         AQ32=ifelse(as.numeric(AQJH_032)>=3,1,0),AQ34=ifelse(as.numeric(AQJH_034)>=3,1,0),AQ36=ifelse(as.numeric(AQJH_036)>=3,1,0),AQ37=ifelse(as.numeric(AQJH_037)>=3,1,0),AQ38=ifelse(as.numeric(AQJH_038)>=3,1,0), #5
         AQ40=ifelse(as.numeric(AQJH_040)>=3,1,0),AQ44=ifelse(as.numeric(AQJH_044)>=3,1,0),AQ47=ifelse(as.numeric(AQJH_047)>=3,1,0),AQ48=ifelse(as.numeric(AQJH_048)>=3,1,0),AQ49=ifelse(as.numeric(AQJH_049)>=3,1,0), #5
         AQ50=ifelse(as.numeric(AQJH_050)>=3,1,0), #1
         AQhigh=AQ1+AQ3+AQ8+AQ10+AQ11+AQ14+AQ15+AQ17+AQ24+AQ25+AQ27+AQ28+AQ29+AQ30+AQ31+AQ32+AQ34+AQ36+AQ37+AQ38+AQ40+AQ44+AQ47+AQ48+AQ49+AQ50,
         AQ2=ifelse(as.numeric(AQJH_002)<3,1,0),AQ4=ifelse(as.numeric(AQJH_004)<3,1,0),AQ5=ifelse(as.numeric(AQJH_005)<3,1,0),AQ6=ifelse(as.numeric(AQJH_006)<3,1,0),AQ7=ifelse(as.numeric(AQJH_007)<3,1,0), #5
         AQ9=ifelse(as.numeric(AQJH_009)<3,1,0),AQ12=ifelse(as.numeric(AQJH_012)<3,1,0),AQ13=ifelse(as.numeric(AQJH_013)<3,1,0),AQ16=ifelse(as.numeric(AQJH_016)<3,1,0),AQ18=ifelse(as.numeric(AQJH_018)<3,1,0), #5
         AQ19=ifelse(as.numeric(AQJH_019)<3,1,0),AQ20=ifelse(as.numeric(AQJH_020)<3,1,0),AQ21=ifelse(as.numeric(AQJH_021)<3,1,0),AQ22=ifelse(as.numeric(AQJH_022)<3,1,0),AQ23=ifelse(as.numeric(AQJH_023)<3,1,0), #5
         AQ26=ifelse(as.numeric(AQJH_026)<3,1,0),AQ33=ifelse(as.numeric(AQJH_033)<3,1,0),AQ35=ifelse(as.numeric(AQJH_035)<3,1,0),AQ39=ifelse(as.numeric(AQJH_039)<3,1,0),AQ41=ifelse(as.numeric(AQJH_041)<3,1,0), #5
         AQ42=ifelse(as.numeric(AQJH_042)<3,1,0),AQ43=ifelse(as.numeric(AQJH_043)<3,1,0),AQ45=ifelse(as.numeric(AQJH_045)<3,1,0),AQ46=ifelse(as.numeric(AQJH_046)<3,1,0), #4
         AQlow=AQ2+AQ4+AQ5+AQ6+AQ7+AQ9+AQ12+AQ13+AQ16+AQ18+AQ19+AQ20+AQ21+AQ22+AQ23+AQ26+AQ33+AQ35+AQ39+AQ41+AQ42+AQ43+AQ45+AQ46,
         aq_soc_skil=AQ1+AQ11+AQ13+AQ15+AQ22+AQ36+AQ44+AQ45+AQ47+AQ48,
         aq_atten_switching=AQ2+AQ4+AQ10+AQ16+AQ25+AQ32+AQ34+AQ37+AQ43+AQ46,
         aq_atten_detail=AQ5+AQ6+AQ9+AQ12+AQ19+AQ23+AQ28+AQ29+AQ30+AQ49,
         aq_communication=AQ7+AQ17+AQ18+AQ26+AQ27+AQ31+AQ33+AQ35+AQ38+AQ39,
         aq_imagin= AQ3+AQ8+AQ14+AQ20+AQ21+AQ24+AQ40+AQ41+AQ42+AQ50,
         aq_tot=AQhigh+AQlow)
}


##### Function for plotting proportions
PlotProportions <- function(dat,iv,group,xlab,ylab){
  ggplot(dat, aes(x=iv, fill=group)) + 
  geom_bar(position="fill",colour="black",alpha=0.7) +
  ylab(ylab) +
  my_theme() +
  xlab(xlab) +
  scale_fill_manual(values=my_palette) +
  scale_color_manual(values=my_palette)
}

########## covariation matrix ##########
cor.mtest <- function(mat, conf.level = 0.95){
  mat <- as.matrix(mat)
  n <- ncol(mat)
  p.mat <- lowCI.mat <- uppCI.mat <- matrix(NA, n, n)
  diag(p.mat) <- 0
  diag(lowCI.mat) <- diag(uppCI.mat) <- 1
  for(i in 1:(n-1)){
    for(j in (i+1):n){
      tmp <- cor.test(mat[,i], mat[,j], conf.level = conf.level)
      p.mat[i,j] <- p.mat[j,i] <- tmp$p.value
      lowCI.mat[i,j] <- lowCI.mat[j,i] <- tmp$conf.int[1]
      uppCI.mat[i,j] <- uppCI.mat[j,i] <- tmp$conf.int[2]
    }
  }
  return(list(p.mat, lowCI.mat, uppCI.mat))
}

cor.Plot <- function(data){
  Matrix <- na.omit(data)
  corTest <- cor.mtest(Matrix,0.95)
  correlations <- cor(Matrix,use="all.obs",method="pearson")
  corrplot(correlations,p.mat = corTest[[1]],sig.level=0.05,method="color")
}

##### zscore function #####
scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

##### TScore function #####
TScore <- function(x){
  z <- scale(x)
  TScore  <- z*10+50
}

##### Bar plot for looking at grouped data #####
barPlot <- function(dat,iv,dv,grp,xlab,ylab,errorBars){
  ggplot(dat, aes(x = iv, y = dv, fill = grp)) +
    geom_bar(position=dodge,stat="identity",colour="white",alpha=0.8) +
    geom_errorbar(errorBars,position=dodge, width=0.1,colour="white") +
    ylab(ylab) +
    my_theme() +
    xlab(xlab) +
    guides(fill=FALSE) +
    guides(color=FALSE) +
    # theme(axis.title.x = element_blank()) +
    scale_fill_manual(values=my_palette) +
    scale_color_manual(values=my_palette)
}

##### Histogram for looking at frequency data #####
histPlot_int <- function(dat,iv,grp,ivLab,bins){
  ggplot(dat, aes(iv, fill = grp)) +
    geom_histogram(binwidth = bins,color="black",alpha=0.8, 
                   position=dodge) +
    xlab(ivLab) +
    my_theme() +
    scale_fill_manual(values=my_palette)
}
histPlot_main <- function(dat,iv,ivLab,bins){
  ggplot(dat, aes(iv)) +
    geom_histogram(binwidth = bins) +
    xlab(ivLab) +
    guides(fill=FALSE) +
    guides(color=FALSE) +
    my_theme() +
    scale_fill_manual(values=my_palette)
}

##### ridgeline plot for looking at posterior distributions by a condition or two #####
ridgePlot_int <- function(dat,dv,grp,ord,xlab,ylab){
  ggplot(dat, aes(x = dv, y = fct_reorder(grp,ord), fill=ord)) +
    geom_density_ridgesgeom_density_ridges()  +
    ylab(ylab) +
    my_theme() +
    xlab(xlab) +
    guides(fill=FALSE) +
    guides(color=FALSE)
}
ridgePlot_main <- function(dat,dv,grp,xlab,ylab){
  ggplot(dat, aes(x = dv, y = fct_reorder(grp,dv), fill=grp)) +
    geom_density_ridgesgeom_density_ridges()  +
    ylab(ylab) +
    my_theme() +
    xlab(xlab) +
    guides(fill=FALSE) +
    guides(color=FALSE)
}

##### Functions for generating confidence intervals and p-values for rlmermod 
# Code for generating wald confidence intervals for rlmer
confint.rlmerMod <- function(object,parm,level=0.95) {
  beta <- fixef(object)
  if (missing(parm)) parm <- names(beta)
  se <- sqrt(diag(vcov(object)))
  z <- qnorm((1+level)/2)
  ctab <- cbind(beta-z*se,beta+z*se)
  colnames(ctab) <- stats:::format.perc(c((1-level)/2,(1+level)/2),
                                        digits=3)
  return(ctab[parm,])
}

# Code for getting p-values from rlmer
pvalue.rlmerMod <- function(lmer_object,rlmer_object) {
  # get coefficients from non-robust model to extract Satterthwaite approximated DFs
  coefs <- data.frame(coef(summary(lmer_object)))
  
  # get coefficients from robust model to extract t-values
  coefs.robust <- coef(summary(rlmer_object))
  
  # calculate p-values based on robust t-values and non-robust approx. DFs
  p.values <- 2*pt(abs(coefs.robust[,3]), coefs$df, lower=FALSE)
  print(p.values)
}

##### My plotting theme (light) #####
my_theme = function(base_size = size, base_family = "") {
  
  theme_grey(base_size = base_size, base_family = base_family) %+replace%
    
    theme(
      # Specify axis options
      axis.line = element_blank(),  
      axis.text.x = element_text(size = base_size*0.8, color = "black", lineheight = 0.9),  
      axis.text.y = element_text(size = base_size*0.8, color = "black", lineheight = 0.9),  
      axis.ticks = element_line(color = "black", size  =  0.2),
      axis.title.x = element_text(size = base_size, color = "black", margin = margin(10, 0, 0, 0)),
      axis.title.y = element_text(size = base_size, color = "black", angle = 90, margin = margin(0, 10, 0, 0)),  
      axis.ticks.length = unit(0.3, "lines"),   
      # Specify legend options
      legend.background = element_rect(color = NA, fill = "#ffffff"),  
      legend.key = element_rect(color = "black",  fill = "#ffffff"),  
      legend.key.size = unit(2, "lines"),  
      legend.key.height = NULL,  
      legend.key.width = NULL,      
      legend.text = element_text(size = base_size*0.8, color = "black"),  
      # legend.title = element_text(size = base_size*0.8, face = "bold", hjust = 0, color = "black"),
      legend.title = element_blank(),
      legend.position = "right",  
      legend.text.align = NULL,  
      legend.title.align = NULL,  
      legend.direction = "vertical",  
      legend.box = NULL, 
      # Specify panel options
      panel.background = element_rect(fill = "#ffffff", color  =  NA),  
      panel.border = element_rect(fill = NA, color = "black"),  
      panel.grid.major = element_line(color = "#ffffff"),  
      panel.grid.minor = element_line(color = "#ffffff"),  
      panel.spacing = unit(2, "lines"),
      # Specify facetting options
      strip.background = element_rect(fill = "grey30", color = "grey10"),  
      strip.text.x = element_text(size = base_size*0.8, color = "black"),  
      strip.text.y = element_text(size = base_size*0.8, color = "black",angle = -90),  
      # Specify plot options
      plot.background = element_rect(color = "#ffffff", fill = "#ffffff"),  
      plot.title = element_text(size = base_size*1.2, color = "black"),  
      plot.margin = unit(rep(1, 4), "lines")
    )
}
##### Black plot theme ##### 
theme_black = function(base_size = size, base_family = "") {
  
  theme_grey(base_size = base_size, base_family = base_family) %+replace%
    
    theme(
      # Specify axis options
      axis.line = element_blank(),  
      axis.text.x = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.text.y = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.ticks = element_line(color = "white", size  =  0.2),
      axis.title.x = element_text(size = base_size, color = "white", margin = margin(10, 0, 0, 0)),
      axis.title.y = element_text(size = base_size, color = "white", angle = 90, margin = margin(0, 10, 0, 0)),  
      axis.ticks.length = unit(0.3, "lines"),   
      # Specify legend options
      legend.background = element_rect(color = NA, fill = "black"),  
      legend.key = element_rect(color = "white",  fill = "black"),  
      legend.key.size = unit(2, "lines"),  
      legend.key.height = NULL,  
      legend.key.width = NULL,      
      legend.text = element_text(size = base_size*0.8, color = "white"),  
      legend.title = element_text(size = base_size*0.8, face = "bold", hjust = 0, color = "white"),
      # legend.title = element_blank(),
      legend.position = "right",  
      legend.text.align = NULL,  
      legend.title.align = NULL,
      legend.direction = "vertical",  
      legend.box = NULL, 
      # Specify panel options
      panel.background = element_rect(fill = "black", color  =  NA),  
      panel.border = element_rect(fill = NA, color = "white"),  
      panel.grid.major = element_line(color = "grey35"),  
      panel.grid.minor = element_line(color = "grey20"),  
      panel.spacing = unit(2, "lines"),
      # Specify facetting options
      strip.background = element_rect(fill = "grey30", color = "grey10"),  
      strip.text.x = element_text(size = base_size*0.8, color = "white"),  
      strip.text.y = element_text(size = base_size*0.8, color = "white",angle = -90),  
      # Specify plot options
      plot.background = element_rect(color = "black", fill = "black"),  
      plot.title = element_text(size = base_size*1.2, color = "white"),  
      plot.margin = unit(rep(1, 4), "lines")
    )
}

##### Plotting boxplots for group-level interactions ##### 
boxPlot_int <- function(dat,iv,dv,Group,xlab,ylab){
  ggplot(dat,aes(x=iv ,y=dv,color=Group,fill=Group))  + 
    geom_dotplot(color="black",binaxis='y', stackdir='center', 
                 position=dodge,size=2,alpha=0.7) +
    # geom_point(position=position_jitterdodge(dodge.width=0.8),size=4) +
    geom_boxplot(color="black",outlier.colour = NA,position =dodge,alpha=0.7) +
    xlab(xlab) +
    ylab(ylab) +
    my_theme() +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    # theme(axis.title.x = element_blank()) +
    scale_fill_manual(values=my_palette) +
    scale_color_manual(values=my_palette) +
    theme(axis.text.x=element_text(angle = -35, vjust = 0.5))
}

##### Plotting boxplots for group-level main effects ##### 
boxPlot_main <- function(dat,iv,dv,Group,xlab,ylab){
  ggplot(dat,aes(x=iv ,y=dv,color=Group,fill=Group))  + 
    geom_dotplot(color="black",binaxis='y', stackdir='center', 
                 position=dodge,size=2,alpha=0.7) +
    # geom_point(position=position_jitterdodge(dodge.width=0.8),size=4) +
    geom_boxplot(color="black",outlier.colour=NA,position=dodge,alpha=0.7) +
    xlab(xlab) +
    ylab(ylab) +
    my_theme() +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    theme(axis.title.x = element_blank()) +
    scale_fill_manual(values=my_palette) +
    scale_color_manual(values=my_palette) +
    theme(axis.text.x=element_text(angle = -35, vjust = 0.5))
}


##### Scatterplots for looking at dimensional relationships #####
scatterPlot_int <- function(dat,iv,dv,grp,xlab,ylab){
  ggplot(dat, aes(x = iv, y = dv, fill = grp)) +
    geom_point(size=4,colour="black",pch=21) +
    geom_smooth(method=lm,   # Add linear regression line
                se=TRUE,
                size = 0.5,
                linetype="dashed",
                alpha=0.7) +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_fill_manual(values=my_palette)
}
scatterPlot_main <- function(dat,iv,dv,xlab,ylab){
  ggplot(dat, aes(x = iv, y = dv)) +
    geom_point(size=4,fill="#3ADF00",colour="black",pch=21) +
    geom_smooth(method=lm,   # Add linear regression line
                se=TRUE,
                size = 0.5,
                linetype="dashed",
                alpha=0.7) +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_fill_manual(values=my_palette)
}

##### Trendline plots for looking at dimensional relationships with messy data #####
trendPlot_int <- function(dat,iv,dv,grp,xlab,ylab){
  ggplot(dat, aes(x = iv, y = dv, fill = grp)) +
    geom_smooth(method=lm,   # Add linear regression line
                se=TRUE,
                size = 0.5,
                linetype="dashed",
                alpha=0.7) +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_fill_manual(values=my_palette)
}
trendPlot_main <- function(dat,iv,dv,xlab,ylab){
  ggplot(dat, aes(x = iv, y = dv)) +
    geom_smooth(method=lm,   # Add linear regression line
                se=TRUE,
                size = 0.5,
                linetype="dashed",
                alpha=0.7) +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_fill_manual(values=my_palette)
}

##### Lineplots for looking at dimensional relationships with messy data #####
linePlot_int <- function(dat,iv,dv,grp,xlab,ylab,errorBars,legTitle){
  ggplot(dat, aes(x = iv, y = dv, color = grp)) +
    geom_line(size=1.5) +
    geom_errorbar(errorBars,position=dodge, width=0.1, size=1.5,colour="black") +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_color_manual(values=my_palette) + 
    guides(color=guide_legend(title=legTitle))
}
linePlot_main <- function(dat,iv,dv,xlab,ylab,errorbars){
  ggplot(dat, aes(x = iv, y = dv)) +
    geom_line() +
    geom_errorbar(errorBars,position=dodge, width=0.1,colour="black") +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_color_manual(values=my_palette)+ 
    guides(color=guide_legend(title=legTitle))
}
linePlot_trials_byCDN <- function(dat,iv,dv,grp,xlab,ylab){
  ggplot(dat, aes(x = iv, y = dv, color = grp)) +
    geom_line() +
    xlab(xlab) +
    ylab(ylab) +
    # guides(fill=FALSE) +
    # guides(color=FALSE) +
    my_theme() +
    scale_color_manual(values=my_palette) + 
    guides(color=guide_legend(title=legTitle))
}

medModels <- function(x,y,m) {
  ########## CALLING IN THE LAVAAN PACKAGE & SETTING UP DATA FRAME ##########
  library(lavaan)
  dat <- data.frame(X=x,Y=y,M=m)
  ########## SPECIFYING THE MODEL ########## 
  model <- ' # direct effect
              Y ~ c*X
              # mediator
              M ~ a*X
              Y ~ b*M
              # indirect effect (a*b)
              ab := a*b
              # total effect
              total := c + (a*b)'
  ########## ESTIMATING THE MODEL ##########
  sem(model, data = dat, se = "bootstrap")
}

###### CONVERTING UNSTANDARDIZED TO STANDARDIZED COEFFICIENTS FROM LMER #####
stdCoef.merMod <- function(object) {
  sdy <- sd(getME(object,"y"))
  sdx <- apply(getME(object,"X"), 2, sd)
  sc <- fixef(object)*sdx/sdy
  se.fixef <- coef(summary(object))[,"Std. Error"]
  se <- se.fixef*sdx/sdy
  return(data.frame(stdcoef=sc, stdse=se))
}

bayes_corComp <- function(fit1,fit2) {
  # COMPARE GROUPS
  fit1 <-as.data.frame(fit1)
  fit2 <- as.data.frame(fit2)
  rho_diff <- fit1$rho - fit2$rho
  plot(hist(rho_diff))
  print(quantile(rho_diff, c(0.05, 0.5, 0.95)))
  print(mean(rho_diff<0))
}

partCorPlot <- function(mat_ASD,mat_TYP,xlab) {
  newMat <- as.data.frame(bind_rows(mat_ASD,mat_TYP, .id = "source")) %>% 
    mutate(diag=ifelse(source==1,"ASD","TYP"))
  errorBars <- aes(ymax = newMat$correlation + (newMat$upperCI - newMat$correlation),
                   ymin = newMat$correlation - (newMat$correlation - newMat$lowerCI))
  level_order <- c('PSM','PVT','LSWM')
  ggplot(newMat, aes(x= factor(vars, levels=level_order), y=correlation, fill=diag, group=diag)) + 
  geom_bar(position=position_dodge(0.7), stat="identity",colour="black",alpha=0.8) +
  geom_errorbar(errorBars,position=position_dodge(0.7), width=0.2,size=0.2,colour="black") +
  xlab(xlab) +
  ylab("Partial Correlation (rho)") +
  scale_fill_manual(values=my_palette) +
  my_theme() +
  geom_hline(yintercept = 0, color="black", size=2)
  }

########## KRUSCHKE PACKAGES FOR Bayesian Multiple Linear Regression ##########
########## Reference: www.indiana.edu/~kruschke/BMLR/ ##########
##### plotPost.R #####
plotPost = function( paramSampleVec , credMass=0.95 , compVal=NULL ,
                     HDItextPlace=0.7 , ROPE=NULL , yaxt=NULL , ylab=NULL ,
                     xlab=NULL , cex.lab=NULL , cex=NULL , xlim=NULL , main=NULL ,
                     col=NULL , border=NULL , showMode=F , showCurve=F , breaks=NULL , 
                     ... ) {
  # Override defaults of hist function, if not specified by user:
  # (additional arguments "..." are passed to the hist function)
  if ( is.null(xlab) ) xlab="Parameter"
  if ( is.null(cex.lab) ) cex.lab=1.5
  if ( is.null(cex) ) cex=1.4
  if ( is.null(xlim) ) xlim=range( c( compVal , paramSampleVec ) )
  if ( is.null(main) ) main=""
  if ( is.null(yaxt) ) yaxt="n"
  if ( is.null(ylab) ) ylab=""
  if ( is.null(col) ) col="skyblue"
  if ( is.null(border) ) border="white"
  
  postSummary = matrix( NA , nrow=1 , ncol=11 , 
                        dimnames=list( c( xlab ) , 
                                       c("mean","median","mode",
                                         "hdiMass","hdiLow","hdiHigh",
                                         "compVal","pcGTcompVal",
                                         "ROPElow","ROPEhigh","pcInROPE")))              
  postSummary[,"mean"] = mean(paramSampleVec)
  postSummary[,"median"] = median(paramSampleVec)
  mcmcDensity = density(paramSampleVec)
  postSummary[,"mode"] = mcmcDensity$x[which.max(mcmcDensity$y)]
  
  source("~/OneDrive - UC Davis/R_scripts/BMLR/HDIofMCMC.R")
  HDI = HDIofMCMC( paramSampleVec , credMass )
  postSummary[,"hdiMass"]=credMass
  postSummary[,"hdiLow"]=HDI[1]
  postSummary[,"hdiHigh"]=HDI[2]
  
  # Plot histogram.
  if ( is.null(breaks) ) {
    breaks = c( seq( from=min(paramSampleVec) , to=max(paramSampleVec) ,
                     by=(HDI[2]-HDI[1])/18 ) , max(paramSampleVec) )
  }
  if ( !showCurve ) {
    par(xpd=NA)
    histinfo = hist( paramSampleVec , xlab=xlab , yaxt=yaxt , ylab=ylab ,
                     freq=F , border=border , col=col ,
                     xlim=xlim , main=main , cex=cex , cex.lab=cex.lab ,
                     breaks=breaks , ... )
  }
  if ( showCurve ) {
    par(xpd=NA)
    histinfo = hist( paramSampleVec , plot=F )
    densCurve = density( paramSampleVec , adjust=2 )
    plot( densCurve$x , densCurve$y , type="l" , lwd=5 , col=col , bty="n" ,
          xlim=xlim , xlab=xlab , yaxt=yaxt , ylab=ylab ,
          main=main , cex=cex , cex.lab=cex.lab , ... )
  }
  cenTendHt = 0.9*max(histinfo$density)
  cvHt = 0.7*max(histinfo$density)
  ROPEtextHt = 0.55*max(histinfo$density)
  # Display mean or mode:
  if ( showMode==F ) {
    meanParam = mean( paramSampleVec )
    text( meanParam , cenTendHt ,
          bquote(mean==.(signif(meanParam,3))) , adj=c(.5,0) , cex=cex )
  } else {
    dres = density( paramSampleVec )
    modeParam = dres$x[which.max(dres$y)]
    text( modeParam , cenTendHt ,
          bquote(mode==.(signif(modeParam,3))) , adj=c(.5,0) , cex=cex )
  }
  # Display the comparison value.
  if ( !is.null( compVal ) ) {
    cvCol = "darkgreen"
    pcgtCompVal = round( 100 * sum( paramSampleVec > compVal )
                         / length( paramSampleVec )  , 1 )
    pcltCompVal = 100 - pcgtCompVal
    lines( c(compVal,compVal) , c(0.96*cvHt,0) ,
           lty="dotted" , lwd=1 , col=cvCol )
    text( compVal , cvHt ,
          bquote( .(pcltCompVal)*"% < " *
                    .(signif(compVal,3)) * " < "*.(pcgtCompVal)*"%" ) ,
          adj=c(pcltCompVal/100,0) , cex=0.8*cex , col=cvCol )
    postSummary[,"compVal"] = compVal
    postSummary[,"pcGTcompVal"] = ( sum( paramSampleVec > compVal ) 
                                    / length( paramSampleVec ) )
  }
  # Display the ROPE.
  if ( !is.null( ROPE ) ) {
    ropeCol = "darkred"
    pcInROPE = ( sum( paramSampleVec > ROPE[1] & paramSampleVec < ROPE[2] )
                 / length( paramSampleVec ) )
    lines( c(ROPE[1],ROPE[1]) , c(0.96*ROPEtextHt,0) , lty="dotted" , lwd=2 ,
           col=ropeCol )
    lines( c(ROPE[2],ROPE[2]) , c(0.96*ROPEtextHt,0) , lty="dotted" , lwd=2 ,
           col=ropeCol)
    text( mean(ROPE) , ROPEtextHt ,
          bquote( .(round(100*pcInROPE))*"% in ROPE" ) ,
          adj=c(.5,0) , cex=1 , col=ropeCol )
    
    postSummary[,"ROPElow"]=ROPE[1] 
    postSummary[,"ROPEhigh"]=ROPE[2] 
    postSummary[,"pcInROPE"]=pcInROPE
  }
  # Display the HDI.
  lines( HDI , c(0,0) , lwd=4 )
  text( mean(HDI) , 0 , bquote(.(100*credMass) * "% HDI" ) ,
        adj=c(.5,-1.7) , cex=cex )
  text( HDI[1] , 0 , bquote(.(signif(HDI[1],3))) ,
        adj=c(HDItextPlace,-0.5) , cex=cex )
  text( HDI[2] , 0 , bquote(.(signif(HDI[2],3))) ,
        adj=c(1.0-HDItextPlace,-0.5) , cex=cex )
  par(xpd=F)
  #
  return( postSummary )
}

##### Open Graph Save Graph #####
# openGraphSaveGraph.R

openGraph = function( width=7 , height=7 , ... ) {
  if ( .Platform$OS.type != "windows" ) { # Mac OS, Linux
    X11( width=width , height=height , type="cairo" , ... )
  } else { # Windows OS
    windows( width=width , height=height , ... )
  }
}

# saveGraph = function( file="saveGraphOutput" , type="pdf" , ... ) {
#   if ( .Platform$OS.type != "windows" ) { # Mac OS, Linux
#     if ( any( type == c("png","jpeg","jpg","tiff","bmp")) ) {
#       sptype = type
#       if ( type == "jpg" ) { sptype = "jpeg" }
#       savePlot( file=paste(file,".",type,sep="") , type=sptype , ... )     
#     }
#     if ( type == "pdf" ) {
#       dev.copy2pdf(file=paste(file,".",type,sep="") , ... )
#     }
#     if ( type == "eps" ) {
#       dev.copy2eps(file=paste(file,".",type,sep="") , ... )
#     }
#   } else { # Windows OS
#     savePlot( file=file , type=type , ... )
#   }
# }

##### HDI #####
HDIofMCMC = function( sampleVec , credMass=0.95 ) {
  # Computes highest density interval from a sample of representative values,
  #   estimated as shortest credible interval.
  # Arguments:
  #   sampleVec
  #     is a vector of representative values from a probability distribution.
  #   credMass
  #     is a scalar between 0 and 1, indicating the mass within the credible
  #     interval that is to be estimated.
  # Value:
  #   HDIlim is a vector containing the limits of the HDI
  sortedPts = sort( sampleVec )
  ciIdxInc = floor( credMass * length( sortedPts ) )
  nCIs = length( sortedPts ) - ciIdxInc
  ciWidth = rep( 0 , nCIs )
  for ( i in 1:nCIs ) {
    ciWidth[ i ] = sortedPts[ i + ciIdxInc ] - sortedPts[ i ]
  }
  HDImin = sortedPts[ which.min( ciWidth ) ]
  HDImax = sortedPts[ which.min( ciWidth ) + ciIdxInc ]
  HDIlim = c( HDImin , HDImax )
  return( HDIlim )
}


##### BMLR.R #####
BMLRmcmc = function( dataMat , numSavedSteps=250000 , checkConvergence=FALSE ) {
  # Program written in the style of
  require(rjags)     # Kruschke, J. K. (2011). Doing Bayesian Data Analysis:
  # A Tutorial with R and JAGS. Academic Press / Elsevier.
  #------------------------------------------------------------------------------
  # THE MODEL.
  modelstring = "
  # JAGS model specification begins here...
  model {
  # Likelihood:
  for( i in 1:N ) {
  y[i] ~ dnorm( y.hat[i] , tau )
  y.hat[i] <- b0 +  inprod( b[1:nPred] , x[i,1:nPred] )
  }
  # Prior (assumes standardized data):
  tau <- 1/pow(sigma,2)
  sigma ~ dunif( 0 , 10 )
  b0 ~ dnorm( 0 , 1.0E-2 ) 
  for ( j in 1:nPred ) {
  b[j] ~ dnorm( 0 , 1.0E-2 )
  }
  }
  # ... end JAGS model specification
  " # close quote for modelstring
  writeLines(modelstring,con="model.txt")
  
  #------------------------------------------------------------------------------
  # THE DATA.
  
  # dataMat is supplied as an argument to this function.
  # The program assumes that the first column is y, and the remaining columns
  # are x (predictors).
  
  # Now re-name variables from dataMat:
  N = NROW(dataMat)
  y = cbind(as.matrix(dataMat[,1]))
  predictedName = colnames(dataMat)[1]
  x = as.matrix(dataMat[,-1]) 
  predictorNames = colnames(dataMat)[-1]
  nPred = NCOL(x)
  
  # Prepare data for JAGS:
  # Re-center data at mean, to reduce autocorrelation in MCMC sampling.
  # Divide by SD to make prior specification generic.
  standardizeCols = function( dataMat ) {
    zDataMat = dataMat
    for ( colIdx in 1:NCOL( dataMat ) ) {
      mCol = mean( dataMat[,colIdx] )
      sdCol = sd( dataMat[,colIdx] )
      zDataMat[,colIdx] = ( dataMat[,colIdx] - mCol ) / sdCol
    }
    return( zDataMat )
  }
  zx = standardizeCols( x )
  zy = standardizeCols( y )
  
  # Get the data into JAGS:
  dataList = list(
    x = zx ,
    y = as.vector( zy ) , # JAGS does not treat 1-column mat as vector
    N = N ,
    nPred = nPred
  )
  
  #------------------------------------------------------------------------------
  # INTIALIZE THE CHAINS.
  
  # Start the chains at the least-squares fit:
  lmInfo = lm( dataList$y ~ dataList$x )
  initsList = list(
    b0 = lmInfo$coef[1] ,   
    b = lmInfo$coef[-1] ,        
    sigma = sqrt(mean(lmInfo$resid^2)) 
  )
  
  #------------------------------------------------------------------------------
  # RUN THE CHAINS
  
  parameters = c("b0" , "b" , "sigma" )  
  adaptSteps = 1000          # Number of steps to "tune" the samplers.
  burnInSteps = 1000        # Number of steps to "burn-in" the samplers.
  nChains = 3               # Number of chains to run.
  #numSavedSteps=250000       # Total number of steps in chains to save.
  thinSteps=1               # Number of steps to "thin" (1=keep every step).
  nPerChain = ceiling( ( numSavedSteps * thinSteps ) / nChains ) # Steps per chain.
  # Create, initialize, and adapt the model:
  jagsModel = jags.model( "model.txt" , data=dataList , inits=initsList , 
                          n.chains=nChains , n.adapt=adaptSteps )
  # Burn-in:
  cat( "Burning in the MCMC chain...\n" )
  update( jagsModel , n.iter=burnInSteps )
  # The saved MCMC chain:
  cat( "Sampling final MCMC chain...\n" )
  codaSamples = coda.samples( jagsModel , variable.names=parameters , 
                              n.iter=nPerChain , thin=thinSteps )
  # resulting codaSamples object has these indices: 
  #   codaSamples[[ chainIdx ]][ stepIdx , paramIdx ]
  
  #------------------------------------------------------------------------------
  # EXAMINE THE RESULTS
  
  if ( checkConvergence ) {
    openGraph(width=7,height=7)
    autocorr.plot( codaSamples[[1]] , ask=FALSE )
    show( gelman.diag( codaSamples ) )
    effectiveChainLength = effectiveSize( codaSamples ) 
    show( effectiveChainLength )
  }
  
  # Convert coda-object codaSamples to matrix object for easier handling.
  # But note that this concatenates the different chains into one long chain.
  # Result is mcmcChain[ stepIdx , paramIdx ]
  mcmcChain = as.matrix( codaSamples )
  chainLength = NROW(mcmcChain)
  
  # Rename results, for convenience:
  zsigma = mcmcChain[,"sigma" ]
  zb0 = mcmcChain[,"b0"]
  zb = matrix( 0 , nrow=chainLength , ncol=nPred )
  for ( j in 1:nPred ) {
    zb[,j] = mcmcChain[,paste("b[",j,"]",sep="")]
  }
  colnames(zb) = paste("zb",1:nPred,sep="")
  
  # Convert to original scale (see book Eqn 17.1):
  sigma = zsigma * sd(as.vector(y))
  # for b0:
  subtractTerm = rep(0,chainLength)
  for ( j in 1:nPred ) {
    subtractTerm = subtractTerm + zb[,j] * sd(as.vector(y)) * mean(x[,j]) / sd(x[,j])
  }
  b0 = zb0 * sd(as.vector(y)) + mean(y) - subtractTerm 
  # for b:
  b = 0*zb 
  for ( j in 1:nPred ) {
    b[,j] = zb[,j] * sd(as.vector(y)) / sd(x[,j])
  }
  colnames(b) = paste("b",1:nPred,sep="")
  
  # Compute R^2 for credible parameters:
  Rsq = rep(0,chainLength)
  YcorX = cor( y , x ) # correlation of y with each x predictor
  for ( stepIdx in 1:chainLength ) {
    Rsq[stepIdx] = sum( zb[stepIdx,] * YcorX )
  }
  ## Old version, perhaps useless:
  #Rsq = rep(0,chainLength)
  #for ( stepIdx in 1:chainLength ) {
  #  predY = dataList$x %*% cbind(zb[stepIdx,]) + zb0[stepIdx]
  #  Rsq[stepIdx] = cor(dataList$y,predY)^2
  #}
  
  # Combine results into one big matrix:
  mcmcChain = cbind( zsigma,zb0,zb, sigma,b0,b, Rsq )
  return( mcmcChain )
}


BMLRplot = function( mcmcChain , filepath , ROPEbeta=NULL , ROPEbetaDiff=NULL ) {
  
  summaryMatrix = matrix( NA , nrow=0 , ncol=11 , 
                          dimnames=list(ParameterName=NULL,PosteriorInfo=NULL) )
  
  # Compute number of predictors from NCOL of mcmcChain matrix. 
  # Assumes mcmcChain has columns zsigma,zb0,zb,sigma,b0,b,Rsq
  nPred = (NCOL(mcmcChain)-1)/2 - 2
  
  # Display scatter plots of parameter values, pairwise:
  openGraph(width=7,height=7)
  chainLength = NROW(mcmcChain)
  nToPlot = 700
  plotIdx = seq(1,chainLength,by=ceiling(chainLength/nToPlot))
  pairs( mcmcChain[plotIdx,c("Rsq","zsigma","zb0",paste("zb",1:nPred,sep=""))] ,  
         col="skyblue" )
  savePlot(filename=paste(filepath,"standardPairwiseScatter.png",sep="_"),type="png",device=dev.cur())
  openGraph(width=7,height=7)
  pairs( mcmcChain[plotIdx,c("Rsq","sigma","b0",paste("b",1:nPred,sep=""))] ,  
         col="skyblue" )
  savePlot(filename=paste(filepath,"unstandardPairwiseScatter.png",sep="_"),type="png",device=dev.cur())
  
  #   # Show correlation matrix on console:
  #   cat("\nCorrlations of posterior sigma, b0, and b's:\n")
  #   show( round( cor( mcmcChain ) , 3) )
  #   cat("\nCovariances of posterior sigma, b0, and b's:\n")
  #   show( round( cov( mcmcChain ) , 5) )
  
  # Display the marginals of posterior:
  nPostCol = 3 # arbitrary number of columns for display
  nPostRow = ceiling((3+nPred)/nPostCol)
  openGraph(width=nPostCol*2.5,height=nPostRow*2.0)
  layout(matrix(1:(nPostCol*nPostRow),nrow=nPostRow,byrow=TRUE))
  par( mar=c(4,2,3,1) , mgp=c(2.5,0.7,0) )
  histInfo = plotPost( mcmcChain[,"Rsq"] , xlab=bquote(R^2) , main="" ,
                       cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  summaryMatrix = rbind( summaryMatrix , histInfo )
  histInfo = plotPost( mcmcChain[,"zsigma"] , xlab=bquote(sigma[z]) , main="" ,
                       cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  summaryMatrix = rbind( summaryMatrix , histInfo )
  histInfo = plotPost( mcmcChain[,"zb0"] , xlab=bquote(beta[0]) , main="" ,
                       cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  summaryMatrix = rbind( summaryMatrix , histInfo )
  for ( j in 1:nPred ) {
    histInfo = plotPost( mcmcChain[,paste("zb",j,sep="")] , 
                         xlab=bquote(beta[.(j)]) , main="" ,
                         compVal = 0.0 , ROPE=ROPEbeta ,
                         cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
    summaryMatrix = rbind( summaryMatrix , histInfo )
  }
  savePlot(filename=paste(filepath,"standardPosterior.png",sep="_"),type="png",device=dev.cur())
  #
  nPostCol = 3 # arbitrary number of columns for display
  nPostRow = ceiling((3+nPred)/nPostCol)
  openGraph(width=nPostCol*2.5,height=nPostRow*2.0)
  layout(matrix(1:(nPostCol*nPostRow),nrow=nPostRow,byrow=TRUE))
  par( mar=c(4,2,3,1) , mgp=c(2.5,0.7,0) )
  histInfo = plotPost( mcmcChain[,"Rsq"] , xlab=bquote(R^2) , main="" ,
                       cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  #summaryMatrix = rbind( summaryMatrix , histInfo )
  histInfo = plotPost( mcmcChain[,"sigma"] , xlab=bquote(sigma[y]) , main="" ,
                       cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  summaryMatrix = rbind( summaryMatrix , histInfo )
  histInfo = plotPost( mcmcChain[,"b0"] , xlab=bquote(b[0]) , main="" ,
                       cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  summaryMatrix = rbind( summaryMatrix , histInfo )
  for ( j in 1:nPred ) {
    histInfo = plotPost( mcmcChain[,paste("b",j,sep="")] , 
                         xlab=bquote(b[.(j)]) , main="" ,
                         compVal = 0.0 ,
                         cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
    summaryMatrix = rbind( summaryMatrix , histInfo )
  }
  savePlot(filename=paste(filepath,"unstandardPosterior.png",sep="_"),type="png",device=dev.cur())
  # # Display differences of standardized regression coefficients:
  # nPostCol = 3
  # nPostCell = nPred*(nPred-1)/2
  # nPostRow = ceiling(nPostCell/nPostCol)
  # openGraph(width=nPostCol*2.5,height=nPostRow*2.0)
  # layout(matrix(1:(nPostCol*nPostRow),nrow=nPostRow,byrow=TRUE))
  # par( mar=c(4,2,3,1) , mgp=c(2.5,0.7,0) )
  # for ( j in 1:(nPred-1) ) {
  #   for ( k in (j+1):nPred ) {
  #     histInfo = plotPost( mcmcChain[,paste("zb",j,sep="")]
  #                          - mcmcChain[,paste("zb",k,sep="")], 
  #                          xlab=bquote(beta[.(j)] - beta[.(k)]) , main="" ,
  #                          compVal = 0.0 , ROPE=ROPEbetaDiff ,
  #                          cex.main=1.67 , cex.lab=1.67 , col="skyblue" )
  #     summaryMatrix = rbind( summaryMatrix , histInfo )
  #   }
  # }
  # 
  # return( summaryMatrix )
  # savePlot(filename=paste(filepath,"standardCoeffDiff.png",sep="_"),type="png",device=dev.cur())
} # end of function BMLRplot